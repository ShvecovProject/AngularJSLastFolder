/**
 * Created by Shvecov_Evgeniy on 14.12.2015.
 */
angular.module('hello', [ ]).controller('HelloWorldCtrl', function($scope){
    $scope.first_name = 'World';
    $scope.last_name = "Worlds";
    $scope.getFirstName = function(){
        return $scope.first_name;
    };
    $scope.getLastName = function(){
        return $scope.last_name;
    };
});

var NotificationService = function() {
    this.MAX_LENGTH = 10;
    this.notificationArchive = new ArtificationArchive();
    this.notifications = [];
};
NotificationService.prototype.push = function(notification) {
    var newLen,
        notificationToArchive;

    newLen = this.notifications.unshift(notification);
    if (newLen > this.MAX_LENGTH) {
        notificationToArchive = this.notifications.pop();
        this.notificationArchive.archive(notificationToArchive);
    }

};
var ArtificationArchive = function(){

};

/*
Сам ангуляр определяет глобальное просторанство имен angular. В нем находятся различные вспомогательные функции и утилиты,
в число которых входит также функция module.
Функция module действует как контейнер для других обьектов(контроллеров, служб и тд), управляемых AngularJS

Что бы определить новый модуль необходимо передать функции module его имя в первом аргументе.
С помошью второго аргумента можно определить зависимости от других модулей.
В ответ функция module возвращает экземпляр вновь созданного модуля. Получив доступ к этому экземпляру
мы можем приступать к определению новых контроллеров, для чего достаточно вызвать функцию controller
со следующими аргументами:
* имя конроллера
* функция конструктор контроллера

После обявления модуля необходимо сообщить AngularJS о его существовании
для этого: нужно указать имя модуля в аттрибуте ng-app
                ng-app="hello"

взаимодействие обьектов
 Внедрение зависимостей
 Angular JS - имеет встроенный механизм внедрения зависимостей(DI)
 Он может выполнять следующие действия:
 * распозновать потребности во вспомогательных обьектах, выражаемых декларативным способом
 * находить необходимые вспомогательные обьекты
 * связывать обьекты между собой
Возможность декларативно выражать зависимоти предосталяет широчайшие возможности, она особождает
от необходимости беспокоиться о жизненом цикле вспомогательных обьектов.
Что еще лучше, взаимозаменяемость вспомогательных обьектов позволяет создать различные
приложения простой заменой одних служб другими.

Внедрение зависимостей

angularJS способен создавать обьекты которые ему знакомы.
1) Регистрация обьектов в модуле AngularJS
В AngularJS  существует выделенная служба provide позволяющая регистрировать различные рецепты создания обьектов
Эти инструкции по созданию обьектов потом используються службой $ingector
для создания готовых к применению экземпляров обьектов.

Обьекты созданные службой $injector также называют службами.
Все службы синглтоны


                                            Значения
Самый простой способ зарегестрировать службу в AngularJS
var myMod = angular.module('myMod',[]);
myMod.value('notificationArchive',new NotificationArchive() );

Любая служба в AngularJS DI, должна иметь уникальное имя,

Обьекты значения - не могут иметь зависимостей от других обьектов.
На практике этот метод используеться лишь для регистрации самых простых обьектов.
Обычно литералов.

                                               Службы
Службу NotificationService - нельзя зарегестрировать как обьект-значение, потому что необходимо выразить зависимость от
службы архивирования.

Самый простой способ зарегестрировать рецепт создания обьекта зависящего от другого обьекта или обьектов  -
указать функцию конструктор.
Сделать это можно с помошью метода service

myMod.service('notificationService',NotificationService);
где конструктор может быть реализован так:
 var NotificationService = function(notificationArchive){
 this.notificationArchive = notificationArchive;
 }

 Воспользовавшись механизмом внедрения зависимостей мы добились в AngularJS
 отказатся от клюдчевого слова new. Теперь эта служба не занимаеться созданием экземпляра своей зависимости
 и может принять любую службу архивирования.

 На практике метод service применяеться нечасто, но его удобно использовать для регистрации уже имеющихся функций
 конструкторов и тем самым заставлять Angular управлять обьектами созданными этими конструкторами.

                                            Фабрики
Метод factory  - еще один способ регистрации алгоритма создания обьекта. Он обеспечивает большую гибкость, чем метод
service, так как способен регистрировать любые функции, создающие и возвращающие обьекты.

myMod.factory('notificationService', function(notificationArchive){
        var MAX_LEN = 10,
        notification = [];
        return {
                push:function(notification){
                 var notificationToArchive,
                       newLen = this.notifications.unshift(notification);  //private
                 if (newLen > this.MAX_LENGTH) {
                         notificationToArchive = this.notifications.pop();
                         this.notificationArchive.archive(notificationToArchive);
                   }
                },
        }

});

Angular будет использовать указанную фабричную функцию для регистрации возвращаемого обьекта.
Метод factory самый наиболее часто используемый прием регистрации обьектов в подсистеме Angular
Он обладает большой гибкостью и может принимать достаточно сложную логику создания.
Так как фабрики фактически являються функциями мы можем использовать  приватную область видимости.

                                        Константы
Фреймворк позволяет определить константы на уровне модуля и внедрять их в обьекты.

Константы очень удобны для создания служб, которые могут использоваться различными приложениями,
Единственным минуч констант - если служба обьявляет зависимость от константы, клиент обязан задать значение константе
myMod.constant('MAX_LENG',10);



                                        Провайдеры
Все методы регистрации являются лишь спец случаями более универсального метода provider

В первую очередь провайдер это функция, которая должна вернуть обьект, обладающий свойством $get
Свойство $get - это фабричная функция, возвращающая экземпляр службы.
Провайдеры можно считать обьектами, встраивающими фабричные ыункции в свойство $get.

/*var myMod = angular.module('myMod',[]);
myMod.provider('notificationService', function(){
    var config = {
        maxLen:10
    };

    var notofications = [];
    return {
        setMaxLength: function(maxLen){
            config.maxLen = maxLen;
        },
        $get:function(notificationsArchive){
            return {
                push:function(notification){

                }
            }
        }
    }
});*/

/*
                                    Жизненный цикл модулей



 */